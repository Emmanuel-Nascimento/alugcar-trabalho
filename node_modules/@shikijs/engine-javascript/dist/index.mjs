import { onigurumaToRegexp } from 'oniguruma-to-js';
import { rewrite } from 'regex';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const MAX = 4294967295;
function defaultJavaScriptRegexConstructor(pattern) {
  pattern = pattern.replaceAll("[^\\s[-?:,\\[\\]{}#&*!|>'\"%@`]]", "[^\\s\\-?:,\\[\\]{}#&*!|>'\"%@`]");
  const rewritten = rewrite(pattern, {
    flags: "dgm",
    unicodeSetsPlugin: null,
    disable: {
      n: true,
      v: true,
      x: true
    }
  });
  return onigurumaToRegexp(
    rewritten.expression,
    {
      flags: "dgm",
      ignoreContiguousAnchors: true
    }
  );
}
class JavaScriptScanner {
  constructor(patterns, cache, forgiving, regexConstructor = defaultJavaScriptRegexConstructor) {
    this.patterns = patterns;
    this.cache = cache;
    this.forgiving = forgiving;
    this.regexConstructor = regexConstructor;
    __publicField(this, "regexps");
    this.regexps = patterns.map((p) => {
      const cached = cache?.get(p);
      if (cached) {
        if (cached instanceof RegExp) {
          return cached;
        }
        if (forgiving)
          return null;
        throw cached;
      }
      try {
        const regex = regexConstructor(p);
        cache?.set(p, regex);
        return regex;
      } catch (e) {
        cache?.set(p, e);
        if (forgiving)
          return null;
        throw e;
      }
    });
  }
  findNextMatchSync(string, startPosition) {
    const str = typeof string === "string" ? string : string.content;
    const pending = [];
    function toResult(index, match) {
      return {
        index,
        captureIndices: match.indices.map((indice) => {
          if (indice == null) {
            return {
              end: MAX,
              start: MAX,
              length: 0
            };
          }
          return {
            start: indice[0],
            length: indice[1] - indice[0],
            end: indice[1]
          };
        })
      };
    }
    for (let i = 0; i < this.regexps.length; i++) {
      const regexp = this.regexps[i];
      if (!regexp)
        continue;
      try {
        regexp.lastIndex = startPosition;
        const match = regexp.exec(str);
        if (!match)
          continue;
        if (match.index === startPosition) {
          return toResult(i, match);
        }
        pending.push([i, match]);
      } catch (e) {
        if (this.forgiving)
          continue;
        throw e;
      }
    }
    if (pending.length) {
      const minIndex = Math.min(...pending.map((m) => m[1].index));
      for (const [i, match] of pending) {
        if (match.index === minIndex) {
          return toResult(i, match);
        }
      }
    }
    return null;
  }
}
function createJavaScriptRegexEngine(options = {}) {
  const {
    forgiving = false,
    cache = /* @__PURE__ */ new Map()
  } = options;
  return {
    createScanner(patterns) {
      return new JavaScriptScanner(patterns, cache, forgiving, options.regexConstructor);
    },
    createString(s) {
      return {
        content: s
      };
    }
  };
}

export { JavaScriptScanner, createJavaScriptRegexEngine, defaultJavaScriptRegexConstructor };
