import { PatternScanner, RegexEngineString, RegexEngine } from '@shikijs/types';

interface JavaScriptRegexEngineOptions {
    /**
     * Whether to allow invalid regex patterns.
     */
    forgiving?: boolean;
    /**
     * Cache for regex patterns.
     */
    cache?: Map<string, RegExp | Error>;
    /**
     * Custom pattern to RegExp constructor.
     *
     * By default `oniguruma-to-js` is used.
     */
    regexConstructor?: (pattern: string) => RegExp;
}
/**
 * The default RegExp constructor for JavaScript regex engine.
 */
declare function defaultJavaScriptRegexConstructor(pattern: string): RegExp;
declare class JavaScriptScanner implements PatternScanner {
    patterns: string[];
    cache: Map<string, RegExp | Error>;
    forgiving: boolean;
    regexConstructor: (pattern: string) => RegExp;
    regexps: (RegExp | null)[];
    constructor(patterns: string[], cache: Map<string, RegExp | Error>, forgiving: boolean, regexConstructor?: (pattern: string) => RegExp);
    findNextMatchSync(string: string | RegexEngineString, startPosition: number): {
        index: number;
        captureIndices: {
            end: number;
            start: number;
            length: number;
        }[];
    } | null;
}
/**
 * Use the modern JavaScript RegExp engine to implement the OnigScanner.
 *
 * As Oniguruma regex is more powerful than JavaScript regex, some patterns may not be supported.
 * Errors will be thrown when parsing TextMate grammars with unsupported patterns.
 * Set `forgiving` to `true` to ignore these errors and skip the unsupported patterns.
 *
 * @experimental
 */
declare function createJavaScriptRegexEngine(options?: JavaScriptRegexEngineOptions): RegexEngine;

export { type JavaScriptRegexEngineOptions, JavaScriptScanner, createJavaScriptRegexEngine, defaultJavaScriptRegexConstructor };
